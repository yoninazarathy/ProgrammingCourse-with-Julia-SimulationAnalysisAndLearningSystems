# Project \#1 - Semester 2, 2022
# Univariate Polynomials with Integer Coefficients

(last edit: September 5, 2022)


**Due:** End of Day, Friday, 23, September, 2022. Late submissions are not accepted.

**Note:** The teaching staff will only answer questions (via Piazza, consultation hour, or practicals) regarding this assignment up to the late evening of Wednesday 21/9.

**Weights and marking criteria:** Total number of points: **100**. There are **10** points for handing in according to the hand-in instructions, including a voice recording, and neat output. There are **10** additional points for setting up the GitHub repo properly. The remaining **80** points are for the project questions.

**Submission format:** This assignment should be submitted via a GitHub Repo and a PDF file via Blackboard. 

Specific instructions for the GitHub repo are below. It is important that the GitHub repo be made **private** and the course user name `uqMATH2504` be invited as a collaborator. It is also important to name the repo exactly as `<<FIRST NAME>>-<<LAST NAME>>-2504-2022-PROJECT1`. So for example if your name is "Colin Kaepernick", the repo name should be `Colin-Kaepernick-2504-2022-PROJECT1`.

The PDF file should be a nice formatted file that has:

* Your name, student number, and assignment title (Project 1 - 2022) on the top.
* A (clickable) link to your GitHub repo.
* An illustration of the code and output for `example_script.jl`: Show the lines of the script and display the corresponding output. 
* An illustration of the output of `test/runtests.jl`. 
* The main body of the PDF file is then an indication of each location of the code project where you made changes and improvements, in view of the tasks below. That is, present the new snippets of code that you created and indicate what they do via brief descriptions.

The recommended way to make the PDF file is via a Jupyter notebook where you copy in some code and output into the notebook, and in certain cases use `include()` to run Julia code if appropriate. You also comment on questions in this PDF (e.g. when asked to answer things not via code). If desired you could keep this jupyter notebook (`.ipynb` file) in the repo. However, this Jupyter notebook will not be checked (only the PDF file), and it isn't required to be a "runnable" notebook. In any case, please avoid pixilated screenshots of code, so for example if you choose to format your PDF file in MS-word (instead of Jupyter), make sure the code is clean, formatted, and readable. 

Marking responses will be made by the teaching staff by annotating **selected parts** of your PDF file via blackboard. The teaching staff will also inspect your GitHub repo. A very readable and clean PDF file is important. Note that in printing Jupyter to PDF (or exporting to PDF) there may sometimes be excessive white space. Do not worry about this extra white space; it is not a problem.

**Individual work**: This is an individual work assignment. Plagiarism will not be accepted. Nevertheless, feel free to consult with friends or classmates via Ed and other means about how to go about certain tasks.

**Marking Criteria**: 

* 10 points are allocated for following instructions. 

* 10 points are allocated for setting up the GitHub hand-in according to the instructions.

* 80 points are for the polynomial project itself. Points are awarded for completing each of the tasks with full marks given to clean readable code that completes the task. 

* In general, points **will be** deducted for sloppy coding style. Make sure to have your code properly indented, to use sensible and consistent variable names, and to write code that is in general clean and consistent. 

---

## Setting up your GitHub repo for hand-in (10pts):

* Ideally use the same account you used for BigHW. 
* Ideally we would like you to **fork** the GitHub repo [https://github.com/yoninazarathy/2504\_2022\_project1](https://github.com/yoninazarathy/2504_2022_project1). The new forked repo under your GitHub account should then be made private. However, GitHub does not allow to make forked repositories private. So instead **duplicate** the repository as described [here](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/duplicating-a-repository). You will first create your new repository and then follow the 4 steps under "Mirroring a repository".
* Invite the course GitHub user, `uqMATH2504` as a collaborator. You may do so early on while working on the project, and you must do this no later than the project due date. You must verify that `uqMATH2504` is a collaborator on your project and let the course staff know if that is not the case.
* Do **not** make any changes (commits) to the repo after the project due date. 
* Create a local clone of the repo. It is recommended that use use `git` command line via the shell to work on making changes/additions to the assignment and submitting the changes. However you are free to use any other mechanism (VS-Code, GitHub desktop, etc). Making intermediate commits is certainly recommended.
* If for some reason you are not able or willing ot use GitHub, an alternative is GitLab. This is not recommended as it adds additional work to the teaching staff. However if you wish to use GitLab instead of GitHub contact the teaching staff for permission.

Your GitHub repo should be formatted like the original repo that you forked with additional files and modifications based on the tasks below.

* Note: make sure that there aren't any excessive files in your submission repo. An exception is perhaps a Jupyter `.ipynb` file if you choose to use it for creating the PDF. Use a `.gitignore` file to ensure `git` does not commit additional files and output files to your `repo`.


## Project tasks (80pts)

You will build your project on top of the [https://github.com/yoninazarathy/2504\_2022\_project1](https://github.com/yoninazarathy/2504_2022_project1) by making modifications, additions, and improvements. Your first goal is to understand every bit of code of the basic repository. After that, you will make improvements, additions, and cleanups.

Please follow the suggested type names below (`PolynomialZeroPacked`, `PolynomialSparseBI` etc..). These are suggested so that tasks have backward compatibility so that you do not throw away old code, but rather add modifications. Note that in an actual project, you would sometimes replace older types with newer ones, and/or use parametric types - a concept which we do not use in this project.

### Task 1 (5 pts) - Getting it to run, improving pretty printing, and creating your own example script.

Once you create your own repository you can make sure it works. Run the code of `test/runtests.jl` and `example_script.jl`. At this point study the functionality of the repository as a user. That is, look at the function signatures but not at the function implementation.  Understand what the repo can do. 

Now create your own example script, `example_script_2.jl`, with a few "thoughtful polynomials" of your own. Your script should run and demonstrate how the code in the repository works. It should also contain some intermediate printing output (e.g. using `println()`) that describes what is going on. So basically, `example_script_2.jl` is an improvement over the minimally supplied `example_script.jl`. With your improved script, make sure you illustrate the key functionality of most of the operations available via the software. Make sure you choose sensible example polynomials and residue classes (primes) to work with.

In addition, as part of this task improve the "pretty printing" of the polynomials. At the moment terms with power `0` or `1` are printed as `x^0` and `x^1`. Similarly negative coefficients are still preceded by a `+` symbol (e.g. `+ -x^2`. Further, leading terms do not need a `+`. Improve this so that polynomials are displayed as cleanly as possible, similarly to common mathematical conventions. 

### Task 2 (15pts) - Refactoring the data structure used

As you can see, the current implementation presumes a dense representation of the coefficients (this is sometimes called a "zero-packed" array). This is fine for small powers and allows quick access to coefficients, yet for polynomials with many zero coefficients, there is a-lot of wasted space. Modify the implementation so that it uses an array containing a sorted list of tuples of powers and coefficients, sorted according to the power from highest to lowest. With this new implementation you no longer need to store terms with zero coefficients.  

Your new polynomial type should be called `PolynomialSparse` and should operate just like the supplied `Polynomial` in terms of all of the functions that have methods working on `Polynomial`. Test the functionality of `PolynomialSparse` on all these functions by creating tests for it. Further, rename the supplied `Polynomial` type to be called `PolynomialDense` (and rename all the methods that use it). Make sure that the original supplied tests and scripts work for the new renamed type `PolynomialDense`. Also modify your solution to Task 1 so that `example_script.jl` is for `PolynomialDense` and `example_script_2.jl` is for `PolynomialSparse`.

Provide a short discussion of the pros and cons of each of the representations, comparing what operations are efficient (both in terms of memory and time) with the original `PolynomialDense` type and what operations are efficient with your new `PolynomialSparse`.

### Task 3 (10pts) - Refactoring the coefficient type from `Int` to `BigInt`

From now on we focus on the sparse representation. 

Refactor the polynomial type (`PolynomialSparse`) to use `BigInt` for the coefficient instead of `Int`. Do this by introducing a new type `PolynomialSparseBI` which is short hand for "Polynomial Big Integer". Note that ideally in Julia we would use parametric types, yet for simplicity of this project just introduce the new type `PolynomialSparseBI` (still you may use parametric types of you wish). Again implement methods for all of the functions that exist for `PolynomialSparse` for `PolynomialSparseBI`. Note that `PolynomialSparseBI` should have a sparse implementation just like `PolynomialSparse`. Write test code of `PolynomialSparseBI` similar to the other types. 

Note that ideally you may also use abstract base types such that functions such as `rand()` and other functions reuse code for `PolynomialSparse`, `PolynomialDense`, and `PolynomialSparseBI`. Feel free to do this, yet you are not required to do so.

Find example cases where `PolynomialSparse` (with `Int` coefficients) overflows and yields the wrong result, while your new `PolynomialSparseBI` does not. The test code for `PolynomialSparseBI` should have such cases. 

Now empirically compare run-time performance of polynomial multiplication with `PolynomialSparse` and `PolynomialSparseBI`. Do this for cases where `PolynomialSparse` does not overflow. You should exhibit faster performance for `PolynomialSparse`.

Hence in general, your results should show that ``PolynomialSparse`` is faster, yet may overflow.

### Task 4 (15pts) - Creating a polynomial mod p datatype and further refactoring

Notice that the `PolynomialDense`, `PolynomialSparse`, and `PolynomialSparseBI` data-types are not aware of the field of the coefficients. Hence operations such as `divide`, `gcd`, or `factor` need to continuously use `mod` and are often with an "unnatural" interface where they return a function which is then gets $p$ (the prime) as an argument. However, sometimes we are interested in polynomials "mod p" where the $p$ is "baked in" into the polynomial.

Your task here is to create a type `PolynomialModP` which has a polynomial (of type `PolynomialDense`) as a fieldname (data member) as well as a prime number (`Int`) as a field name. This `PolynomialModP` type will then support the same arithmetic operations as `PolynomialDense` but will keep all the coefficients in the range $0,1,2,\ldots,p-1$. Unlike the current usage of polynomial arithmetic, your new type will be easier to work with when carrying out division, gcd, and factorization. 

Create units tests for this type just like the ones that currently exist in the package and make sure all of the functionality is kept working (only to this restricted set of polynomials).

Your new datatype should still rely on existing functionality of the type `PolynomialDense`. But, for example, after doing arithmetic operations, it should ensure that all coefficients are represented mod $p$. 

Note that once you complete this task, certain operations of `PolynomialDense` such as `p1 รท p2`, are better done via `PolynomialModP`. That is, while you may use `p1 รท p2` for `p1` and `p2` of types `PolynomialDense`, it is better to use this operation when `p1` and `p2` are of type `PolynomialModP`. The reason for this is that in the `PolynomialDense` case, this operation returns a function which requires $p$ as input, whereas in the `PolynomialModP` case, this operation simply returns the resulting polynomial mod $p$.

With this addition `PolynomialModP` usage of the `pow_mod` function used for `PolynomialDense` can now be replaced with `^` for `PolynomialModP`. That is, implement `^` for `PolynomialModP`.

The `show` method for `PolynomialModP` should also indicate that it is mod p.

### Task 5 (20pts) - Improving multiplication using the Chinese Remainder Theorem

The current multiplication implementation is not efficient for `PolynomialSparseBI`. Implement a different and better form of multiplication using the **Chinese Remainder Theorem** (CRT) as presented in the lecture. Test it and benchmark it against the old multiplication (it is recommended to keep the old form of multiplication in another function or method). 

You will need to implement multiplication for your `PolynomialModP` type first.  Then the generic multiplication algorithm will compute products of a sufficient number of primes using your mod p multiplication, and then use the CRT to construct the solution in ${\mathbb Z}[x]$ (where ${\mathbb Z}$ is a `BitInt`).

Present timing benchmarks showing that your CRT based approach is faster for certain examples.

### Task 6 (15pts) - Factorization mod p and improving power

Now you have efficient multiplication of `PolynomialSparseBI`, power, and the datatype `PolynomialModP` together with the other working operations. Adapt the supplied polynomial factorization code to use this new functionality. The current supplied code works for limited cases but may get stuck on certain examples. 

Similarly to multiplication, you may notice the the implementation of the power operator, `^` as well as `pow_mod` (or its new version in `PolynomialModP`), can be made more efficient. For example if you have a polynomial `f` and raise it to the power `2^n` then instead of doing about `2^n` multiplications you can do about `n`. This can also be done for powers that are not `2^n`. Implement this better power and make sure it works via unit tests. Again this should work both for `PolynomialSparseBI` and `PolynomialModP`. A method for optimizing the `w^p mod p` calculation for `w` a polynomial and `p` a prime, is covered in the lectures. You should use this method where applicable.

With your new code, test on a wider set of examples including bigger primes. Create unit tests for factorization and create benchmarks that test how your factorization works with a compute budget of about 120 seconds on your computer. Note: factorization for small primes may not work and such cases can be ignored.

Finally, you should also modify and enhance the current unit tests supplied with the code to support factorization using all of the described components.